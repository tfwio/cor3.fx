using System;
using System.ComponentModel;
using System.Drawing.Design;
using System.Windows.Forms;
using System.Xml.Serialization;

//using efx.Design;
using efx.xml;

namespace MSVS
{
	//------------------------------------------------------------------------------
	// <auto-generated>
	//     This code was generated by a tool.
	//     Runtime Version:2.0.50727.3053
	//
	//     Changes to this file may cause incorrect behavior and will be lost if
	//     the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.1432")]
	[System.SerializableAttribute()]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[TypeConverter(typeof(ExpandableObjectConverter))]
	public partial class CustomBuildRule : hVal32 {

		public override TreeNode CreateTreeNode()
		{
			TreeNode tnode = base.CreateTreeNode();
			tnode.Text = string.Format("{0}:<{1}>",Name,DisplayName);
			tnode.Tag = this;
			tnode.ContextMenuStrip = new ContextMenuStrip();
			tnode.ContextMenuStrip.Items.AddRange(
				new ToolStripItem[]
				{
					new ToolStripMenuItem("Load",null,delegate { Load(); }),
					new ToolStripMenuItem("Save",null,delegate { Save(); }),
					new ToolStripSeparator(),
				}
			);
			foreach (Property pt in Properties)
			{
				TreeNode stn = tnode.Nodes.Add(pt.Name);
				stn.Tag = pt;
				if (pt is EnumProperty)
				{
					EnumProperty ep = pt as EnumProperty;
					if (ep==null) continue;
					if (ep.Values.EnumValue==null) continue;
					if (ep.Values.EnumValue.Length > 0)
					foreach (EnumValue epv in (pt as EnumProperty).Values.EnumValue)
					{
						stn.Nodes.Add(epv.DisplayName).Tag = epv;
					}
				}
			}
		//	tnode.Expand();
			return tnode;
		}
		[Browsable(false),XmlIgnore] public override TreeNode TreeNode { get {return CreateTreeNode(); } }

		#region vars
	    private Property[] propertiesField;
		#endregion
	    
		public CustomBuildRule() : base() { }
		#region Properties
	    /// <remarks/>
	    [
	    	XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified),
	    	XmlArrayItemAttribute(typeof(BooleanProperty), Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false),
	    	XmlArrayItemAttribute(typeof(EnumProperty), Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false),
	    	XmlArrayItemAttribute(typeof(IntegerProperty), Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false),
	    	XmlArrayItemAttribute(typeof(StringProperty), Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false),
	    	EditorAttribute(typeof(RulesPropertyEditor),typeof(System.Drawing.Design.UITypeEditor)),
	    	DescriptionAttribute("Types: BooleanProperty, EnumProperty,IntegerProperty or StringProperty"),
	    	CategoryAttribute("Design"),
			TypeConverterAttribute(typeof(BrowsableTypeConverter))
 	   ]
	    public Property[] Properties { get { return this.propertiesField; } set { this.propertiesField = value; } }
		public override void InitiailzeValues()
		{
			base.InitiailzeValues();
			Add("Name","New CustomBuildRule");
			Add("DisplayName",string.Empty);
			Add("CommandLine","[ToolPath] $(InputFile) [AllProperties]");
			Add("GeneratedCommandLine","[ToolPath] $(InputFile) [AllProperties]");
			Add("Outputs",string.Empty);
			Add("AdditionalDependencies",string.Empty);
			Add("FileExtensions",string.Empty);
			Add("ExecutionDescription","Executing tool...");
			Add("SupportsFileBatching",false);
			Add("SupportsFileBatchingSpecified",false);
			Add("BatchingSeparator",";,");
			Add("ShowOnlyRuleProperties",false);
		}
	    [XmlAttribute,] public string Name { get { return (string)InnerHashtable["Name"]; } set { InnerHashtable["Name"] = (string)value; } }
	    [XmlAttribute,] public string DisplayName { get { return (string)InnerHashtable["DisplayName"]; } set { InnerHashtable["DisplayName"] = (string)value; } }

	    [EditorAttribute(typeof(MacroLookupEditor),typeof(UITypeEditor))]
	    [XmlAttribute,] public string CommandLine { get { return (string)InnerHashtable["CommandLine"]; } set { InnerHashtable["CommandLine"] = (string)value; } }
	    [XmlAttribute,] public string GeneratedCommandLine { get { return (string)InnerHashtable["GeneratedCommandLine"]; } set { InnerHashtable["GeneratedCommandLine"] = (string)value; } }
	    [XmlAttribute,] public string Outputs { get { return (string)InnerHashtable["Outputs"]; } set { InnerHashtable["Outputs"] = (string)value; } }
	    [XmlAttribute,] public string AdditionalDependencies { get { return (string)InnerHashtable["AdditionalDependencies"]; } set { InnerHashtable["AdditionalDependencies"] = (string)value; } }
	    [XmlAttribute,] public string FileExtensions { get { return (string)InnerHashtable["FileExtensions"]; } set { InnerHashtable["FileExtensions"] = (string)value; } }
	    [XmlAttribute,DefaultValueAttribute("Executing tool..."),] public string ExecutionDescription { get { return (string)InnerHashtable["ExecutionDescription"]; } set { InnerHashtable["ExecutionDescription"] = (string)value; } }
	    [XmlAttribute,] public bool SupportsFileBatching { get { return (bool)InnerHashtable["SupportsFileBatching"]; } set { InnerHashtable["SupportsFileBatching"] = (bool)InnerHashtable["SupportsFileBatching"]; } }
	    [Browsable(false),XmlIgnore] public bool SupportsFileBatchingSpecified { get { return (bool)InnerHashtable["SupportsFileBatchingSpecified"]; } set { InnerHashtable["SupportsFileBatchingSpecified"] = (bool)value; } }
	    [XmlAttribute] public string BatchingSeparator { get { return (string)InnerHashtable["BatchingSeparator"]; } set { InnerHashtable["BatchingSeparator"] = (string)value; } }
	    [XmlAttribute,System.ComponentModel.DefaultValue(false)]
	    public bool ShowOnlyRuleProperties { get { return (bool)InnerHashtable["ShowOnlyRuleProperties"]; } set { InnerHashtable["ShowOnlyRuleProperties"] = (bool)value; } }
		#endregion
	}
}
